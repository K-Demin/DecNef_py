<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<title>BIOPAC Hardware API 2.2.5: mpdev.h File Reference</title>
<style type="text/css">
		@import "biopacapi.css";
		@import "tabs.css";
</style>
</head>
<body>
<!-- Generated on Fri Feb 16 10:56:28 2024 -->
<!-- Generated by Doxygen 1.3.8 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<h1>mpdev.h File Reference</h1>The BIOPAC Hardware API allows third-party software programs to communicate with BIOPAC MP devices. <a href="#_details">More...</a>
<p>

<p>
<a href="mpdev_8h-source.html">Go to the source code of this file.</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="anchor" name="a0" doxytag="mpdev.h::MPDLL_EXPORT" ></a>
#define&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="mpdev_8h.html#a0">MPDLL_EXPORT</a>&nbsp;&nbsp;&nbsp;__declspec(dllexport)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attribute that enables the export of API functions via a DLL *. <br></td></tr>
<tr><td colspan=2><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>typedef enum <a class="el" href="mpdev_8h.html#a79">DIGITAL_OPT</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="mpdev_8h.html#a4">DIGITALOPT</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enumerated Values For the MP Device Digital I/O Options.  <a href="#a4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>typedef enum <a class="el" href="mpdev_8h.html#a81">MP3XOUTPUT_OPT</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="mpdev_8h.html#a6">MP3XOUTMODE</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enumerated Values For MP36R/MP36AR Device Ouput modes.  <a href="#a6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>typedef enum <a class="el" href="mpdev_8h.html#a77">MP_COM_TYPE</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="mpdev_8h.html#a2">MPCOMTYPE</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enumerated Values for the MP Device Communication Types.  <a href="#a2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>typedef enum <a class="el" href="mpdev_8h.html#a80">MP_RETURN_CODE</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="mpdev_8h.html#a5">MPRETURNCODE</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enumerated Return Code Values.  <a href="#a5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>typedef enum <a class="el" href="mpdev_8h.html#a76">MP_TYPE</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="mpdev_8h.html#a1">MPTYPE</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enumerated Values for MP Devices.  <a href="#a1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>typedef enum <a class="el" href="mpdev_8h.html#a78">TRIGGER_OPT</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="mpdev_8h.html#a3">TRIGGEROPT</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enumerated Values For MP Device Triggering Options.  <a href="#a3"></a><br></td></tr>
<tr><td colspan=2><br><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>enum &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="mpdev_8h.html#a79">DIGITAL_OPT</a> { <a class="el" href="mpdev_8h.html#a79a18">SET_LOW_BITS</a> =  1, 
<a class="el" href="mpdev_8h.html#a79a19">SET_HIGH_BITS</a>, 
<a class="el" href="mpdev_8h.html#a79a20">READ_LOW_BITS</a>, 
<a class="el" href="mpdev_8h.html#a79a21">READ_HIGH_BITS</a>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enumerated Values For the MP Device Digital I/O Options.  <a href="#a79">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>enum &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="mpdev_8h.html#a81">MP3XOUTPUT_OPT</a> { <br>
&nbsp;&nbsp;<a class="el" href="mpdev_8h.html#a81a41">OUTPUTVOLTAGELEVEL</a> =  2, 
<a class="el" href="mpdev_8h.html#a81a42">OUTPUTCHANNEL3</a> =  3, 
<a class="el" href="mpdev_8h.html#a81a43">OUTPUTCHANNEL1</a> =  5, 
<a class="el" href="mpdev_8h.html#a81a44">OUTPUTCHANNEL2</a> =  6, 
<br>
&nbsp;&nbsp;<a class="el" href="mpdev_8h.html#a81a45">OUTPUTCHANNEL4</a> =  7, 
<a class="el" href="mpdev_8h.html#a81a46">OUTPUTGROUND</a> =  0x7f
<br>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enumerated Values For MP36R/MP36AR Device Ouput modes.  <a href="#a81">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>enum &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="mpdev_8h.html#a77">MP_COM_TYPE</a> { <a class="el" href="mpdev_8h.html#a77a12">MPUSB</a> =  10, 
<a class="el" href="mpdev_8h.html#a77a13">MPUDP</a>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enumerated Values for the MP Device Communication Types.  <a href="#a77">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>enum &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="mpdev_8h.html#a80">MP_RETURN_CODE</a> { <br>
&nbsp;&nbsp;<a class="el" href="mpdev_8h.html#a80a22">MPSUCCESS</a> =  1, 
<a class="el" href="mpdev_8h.html#a80a23">MPDRVERR</a>, 
<a class="el" href="mpdev_8h.html#a80a24">MPDLLBUSY</a>, 
<a class="el" href="mpdev_8h.html#a80a25">MPINVPARA</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="mpdev_8h.html#a80a26">MPNOTCON</a>, 
<a class="el" href="mpdev_8h.html#a80a27">MPREADY</a>, 
<a class="el" href="mpdev_8h.html#a80a28">MPWPRETRIG</a>, 
<a class="el" href="mpdev_8h.html#a80a29">MPWTRIG</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="mpdev_8h.html#a80a30">MPBUSY</a>, 
<a class="el" href="mpdev_8h.html#a80a31">MPNOACTCH</a>, 
<a class="el" href="mpdev_8h.html#a80a32">MPCOMERR</a>, 
<a class="el" href="mpdev_8h.html#a80a33">MPINVTYPE</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="mpdev_8h.html#a80a34">MPNOTINNET</a>, 
<a class="el" href="mpdev_8h.html#a80a35">MPSMPLDLERR</a>, 
<a class="el" href="mpdev_8h.html#a80a36">MPMEMALLOCERR</a>, 
<a class="el" href="mpdev_8h.html#a80a37">MPSOCKERR</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="mpdev_8h.html#a80a38">MPUNDRFLOW</a>, 
<a class="el" href="mpdev_8h.html#a80a39">MPPRESETERR</a>, 
<a class="el" href="mpdev_8h.html#a80a40">MPPARSERERR</a>
<br>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enumerated Return Code Values.  <a href="#a80">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>enum &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="mpdev_8h.html#a76">MP_TYPE</a> { <br>
&nbsp;&nbsp;<a class="el" href="mpdev_8h.html#a76a7">MP150</a> =  101, 
<a class="el" href="mpdev_8h.html#a76a8">MP36</a>, 
<a class="el" href="mpdev_8h.html#a76a9">MP160</a>, 
<a class="el" href="mpdev_8h.html#a76a10">MP200</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="mpdev_8h.html#a76a11">MP36A</a>
<br>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enumerated Values for MP Devices.  <a href="#a76">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>enum &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="mpdev_8h.html#a78">TRIGGER_OPT</a> { <a class="el" href="mpdev_8h.html#a78a14">MPTRIGOFF</a> =  1, 
<a class="el" href="mpdev_8h.html#a78a15">MPTRIGEXT</a>, 
<a class="el" href="mpdev_8h.html#a78a16">MPTRIGACH</a>, 
<a class="el" href="mpdev_8h.html#a78a17">MPTRIGDCH</a>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enumerated Values For MP Device Triggering Options.  <a href="#a78">More...</a><br></td></tr>
<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>MPDLL_EXPORT <a class="el" href="mpdev_8h.html#a5">MPRETURNCODE</a> <br>
_stdcall&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="mpdev_8h.html#a47">configChannelByPresetID</a> (const DWORD n, const char *uid)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Configure a Channel by Preset ID.  <a href="#a47"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>MPDLL_EXPORT <a class="el" href="mpdev_8h.html#a5">MPRETURNCODE</a> <br>
_stdcall&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="mpdev_8h.html#a48">connectMPDev</a> (const <a class="el" href="mpdev_8h.html#a1">MPTYPE</a> type, const <a class="el" href="mpdev_8h.html#a2">MPCOMTYPE</a> method, const char *MP150SN)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Connect to the Specified MP Device.  <a href="#a48"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>MPDLL_EXPORT <a class="el" href="mpdev_8h.html#a5">MPRETURNCODE</a> <br>
_stdcall&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="mpdev_8h.html#a49">disconnectMPDev</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disconnect from the MP Device.  <a href="#a49"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>MPDLL_EXPORT <a class="el" href="mpdev_8h.html#a5">MPRETURNCODE</a> <br>
_stdcall&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="mpdev_8h.html#a52">findAllMP150</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find All MP150s.  <a href="#a52"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>MPDLL_EXPORT <a class="el" href="mpdev_8h.html#a5">MPRETURNCODE</a> <br>
_stdcall&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="mpdev_8h.html#a50">findAllMP160</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find All MP160s.  <a href="#a50"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>MPDLL_EXPORT <a class="el" href="mpdev_8h.html#a5">MPRETURNCODE</a> <br>
_stdcall&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="mpdev_8h.html#a51">findAllMP200</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find All MP200s.  <a href="#a51"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>MPDLL_EXPORT <a class="el" href="mpdev_8h.html#a5">MPRETURNCODE</a> <br>
_stdcall&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="mpdev_8h.html#a53">getChScaledInputRange</a> (const DWORD n, double *minRange, double *maxRange)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a Channel's Scaled Input Range.  <a href="#a53"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>MPDLL_EXPORT <a class="el" href="mpdev_8h.html#a5">MPRETURNCODE</a> <br>
_stdcall&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="mpdev_8h.html#a54">getDigitalIO</a> (const DWORD n, BOOL *state, const <a class="el" href="mpdev_8h.html#a4">DIGITALOPT</a> opt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the State of the Specified Digital I/O Line.  <a href="#a54"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>MPDLL_EXPORT <a class="el" href="mpdev_8h.html#a5">MPRETURNCODE</a> <br>
_stdcall&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="mpdev_8h.html#a55">getElectrodeCheckImpedance</a> (double *redImpedance, double *whiteImpedance)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the current measured resistances from the electrode checker.  <a href="#a55"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>MPDLL_EXPORT <a class="el" href="mpdev_8h.html#a5">MPRETURNCODE</a> <br>
_stdcall&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="mpdev_8h.html#a56">getMostRecentSample</a> (double data[])</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the Most Recent Sample.  <a href="#a56"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>MPDLL_EXPORT <a class="el" href="mpdev_8h.html#a5">MPRETURNCODE</a> <br>
_stdcall&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="mpdev_8h.html#a57">getMPBuffer</a> (const DWORD numSamples, double buff[])</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the Acquisition Buffer.  <a href="#a57"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>MPDLL_EXPORT <a class="el" href="mpdev_8h.html#a5">MPRETURNCODE</a> <br>
_stdcall&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="mpdev_8h.html#a58">getMPDaemonLastError</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the MP Daemon Last Error.  <a href="#a58"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>MPDLL_EXPORT <a class="el" href="mpdev_8h.html#a5">MPRETURNCODE</a> <br>
_stdcall&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="mpdev_8h.html#a59">getStatusMPDev</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the Status of the MP Device.  <a href="#a59"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>MPDLL_EXPORT <a class="el" href="mpdev_8h.html#a5">MPRETURNCODE</a> <br>
_stdcall&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="mpdev_8h.html#a60">loadXMLPresetFile</a> (const char *filename)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load an XML Preset File.  <a href="#a60"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>MPDLL_EXPORT <a class="el" href="mpdev_8h.html#a5">MPRETURNCODE</a> <br>
_stdcall&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="mpdev_8h.html#a61">readAvailableMP150SN</a> (char buff[], const DWORD numchartoread, DWORD *numcharread)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read the Serial Numbers of Available MP150s.  <a href="#a61"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>MPDLL_EXPORT <a class="el" href="mpdev_8h.html#a5">MPRETURNCODE</a> <br>
_stdcall&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="mpdev_8h.html#a62">readAvailableMP160SN</a> (char buff[], const DWORD numchartoread, DWORD *numcharread)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read the Serial Numbers of Available MP160s.  <a href="#a62"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>MPDLL_EXPORT <a class="el" href="mpdev_8h.html#a5">MPRETURNCODE</a> <br>
_stdcall&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="mpdev_8h.html#a63">readAvailableMP200SN</a> (char buff[], const DWORD numchartoread, DWORD *numcharread)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read the Serial Numbers of Available MP200s.  <a href="#a63"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>MPDLL_EXPORT <a class="el" href="mpdev_8h.html#a5">MPRETURNCODE</a> <br>
_stdcall&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="mpdev_8h.html#a64">receiveMPData</a> (double buff[], const DWORD numdatapoints, DWORD *numreceived)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Receive the MP Data.  <a href="#a64"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>MPDLL_EXPORT <a class="el" href="mpdev_8h.html#a5">MPRETURNCODE</a> <br>
_stdcall&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="mpdev_8h.html#a65">setAcqChannels</a> (const BOOL analogCH[])</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the Analog Channels to Acquire.  <a href="#a65"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>MPDLL_EXPORT <a class="el" href="mpdev_8h.html#a5">MPRETURNCODE</a> <br>
_stdcall&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="mpdev_8h.html#a66">setAnalogChScale</a> (const DWORD n, const double unscaled1, const double scaled1, const double unscaled2, const double scaled2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the Analog Channel Scaling.  <a href="#a66"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>MPDLL_EXPORT <a class="el" href="mpdev_8h.html#a5">MPRETURNCODE</a> <br>
_stdcall&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="mpdev_8h.html#a67">setAnalogOut</a> (const double value, const int outchan)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the Voltage of the Specified Analog Output Channel.  <a href="#a67"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>MPDLL_EXPORT <a class="el" href="mpdev_8h.html#a5">MPRETURNCODE</a> <br>
_stdcall&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="mpdev_8h.html#a68">setAnalogOutputMode</a> (const <a class="el" href="mpdev_8h.html#a6">MP3XOUTMODE</a> mode)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Setup output mode for MP device.  <a href="#a68"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>MPDLL_EXPORT <a class="el" href="mpdev_8h.html#a5">MPRETURNCODE</a> <br>
_stdcall&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="mpdev_8h.html#a69">setDigitalAcqChannels</a> (const BOOL digitalCH[])</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the Digital Channels to Acquire.  <a href="#a69"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>MPDLL_EXPORT <a class="el" href="mpdev_8h.html#a5">MPRETURNCODE</a> <br>
_stdcall&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="mpdev_8h.html#a70">setDigitalIO</a> (const DWORD n, const BOOL state, const BOOL setnow, const <a class="el" href="mpdev_8h.html#a4">DIGITALOPT</a> opt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the State of the Specified Digital I/O Line.  <a href="#a70"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>MPDLL_EXPORT <a class="el" href="mpdev_8h.html#a5">MPRETURNCODE</a> <br>
_stdcall&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="mpdev_8h.html#a71">setMPTrigger</a> (const <a class="el" href="mpdev_8h.html#a3">TRIGGEROPT</a> option, const BOOL posEdge, const double level, const DWORD chNum)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the Triggering Configuration.  <a href="#a71"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>MPDLL_EXPORT <a class="el" href="mpdev_8h.html#a5">MPRETURNCODE</a> <br>
_stdcall&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="mpdev_8h.html#a72">setSampleRate</a> (const double rate)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the MP Device Sample Rate.  <a href="#a72"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>MPDLL_EXPORT <a class="el" href="mpdev_8h.html#a5">MPRETURNCODE</a> <br>
_stdcall&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="mpdev_8h.html#a73">startAcquisition</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start the Acquisition.  <a href="#a73"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>MPDLL_EXPORT <a class="el" href="mpdev_8h.html#a5">MPRETURNCODE</a> <br>
_stdcall&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="mpdev_8h.html#a74">startMPAcqDaemon</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start the Acquisition Daemon.  <a href="#a74"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>MPDLL_EXPORT <a class="el" href="mpdev_8h.html#a5">MPRETURNCODE</a> <br>
_stdcall&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="mpdev_8h.html#a75">stopAcquisition</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stop the Acquisition.  <a href="#a75"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
The BIOPAC Hardware API allows third-party software programs to communicate with BIOPAC MP devices. 
<p>
<dl compact><dt><b>Author:</b></dt><dd>BIOPAC Systems, Inc. </dd></dl>
<dl compact><dt><b>Version:</b></dt><dd>2.2.5 </dd></dl>
The Hardware API is compatible with the MP150, MP160 and MP200 communicating via Ethernet using UDP and the MP36R/MP36AR communicating via USB.<p>
The Hardware API allows developers to create software programs that communicate directly to the MP device.<p>
Using the Hardware API functions, software developers can:<p>
<ul>
<li>Acquire data from the analog and digital channels</li><li>Acquire at different sample rates</li><li>Set triggers</li><li>Get the MP device status</li><li>Use the Analog output channels</li></ul>

<p>
Definition in file <a class="el" href="mpdev_8h-source.html">mpdev.h</a>.<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="a4" doxytag="mpdev.h::DIGITALOPT" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef enum <a class="el" href="mpdev_8h.html#a79">DIGITAL_OPT</a>  <a class="el" href="mpdev_8h.html#a4">DIGITALOPT</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Enumerated Values For the MP Device Digital I/O Options. 
<p>
Represents supported MP digital line reading or writing options.     </td>
  </tr>
</table>
<a class="anchor" name="a6" doxytag="mpdev.h::MP3XOUTMODE" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef enum <a class="el" href="mpdev_8h.html#a81">MP3XOUTPUT_OPT</a>  <a class="el" href="mpdev_8h.html#a6">MP3XOUTMODE</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Enumerated Values For MP36R/MP36AR Device Ouput modes. 
<p>
Represents supported MP36R/MP36AR output modes.     </td>
  </tr>
</table>
<a class="anchor" name="a2" doxytag="mpdev.h::MPCOMTYPE" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef enum <a class="el" href="mpdev_8h.html#a77">MP_COM_TYPE</a>  <a class="el" href="mpdev_8h.html#a2">MPCOMTYPE</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Enumerated Values for the MP Device Communication Types. 
<p>
Represents supported MP communication types.     </td>
  </tr>
</table>
<a class="anchor" name="a5" doxytag="mpdev.h::MPRETURNCODE" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef enum <a class="el" href="mpdev_8h.html#a80">MP_RETURN_CODE</a>  <a class="el" href="mpdev_8h.html#a5">MPRETURNCODE</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Enumerated Return Code Values. 
<p>
Return codes that are generated by Hardware API functions.     </td>
  </tr>
</table>
<a class="anchor" name="a1" doxytag="mpdev.h::MPTYPE" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef enum <a class="el" href="mpdev_8h.html#a76">MP_TYPE</a>  <a class="el" href="mpdev_8h.html#a1">MPTYPE</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Enumerated Values for MP Devices. 
<p>
Represents supported MP devices.     </td>
  </tr>
</table>
<a class="anchor" name="a3" doxytag="mpdev.h::TRIGGEROPT" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef enum <a class="el" href="mpdev_8h.html#a78">TRIGGER_OPT</a>  <a class="el" href="mpdev_8h.html#a3">TRIGGEROPT</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Enumerated Values For MP Device Triggering Options. 
<p>
Represents supported MP triggering options.     </td>
  </tr>
</table>
<hr><h2>Enumeration Type Documentation</h2>
<a class="anchor" name="a79" doxytag="mpdev.h::DIGITAL_OPT" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> enum <a class="el" href="mpdev_8h.html#a79">DIGITAL_OPT</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Enumerated Values For the MP Device Digital I/O Options. 
<p>
Represents supported MP digital line reading or writing options. <dl compact><dt><b>Enumeration values: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="anchor" name="a79a18" doxytag="SET_LOW_BITS" ></a>SET_LOW_BITS</em>&nbsp;</td><td>
set only digital I/O lines 0 through 7 </td></tr>
<tr><td valign=top><em><a class="anchor" name="a79a19" doxytag="SET_HIGH_BITS" ></a>SET_HIGH_BITS</em>&nbsp;</td><td>
set only digital I/O lines 8 through 15 </td></tr>
<tr><td valign=top><em><a class="anchor" name="a79a20" doxytag="READ_LOW_BITS" ></a>READ_LOW_BITS</em>&nbsp;</td><td>
read only digital I/O lines 0 through 7 </td></tr>
<tr><td valign=top><em><a class="anchor" name="a79a21" doxytag="READ_HIGH_BITS" ></a>READ_HIGH_BITS</em>&nbsp;</td><td>
read only digital I/O lines 8 through 15 </td></tr>
</table>
</dl>
Definition at line <a class="el" href="mpdev_8h-source.html#l00068">68</a> of file <a class="el" href="mpdev_8h-source.html">mpdev.h</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a81" doxytag="mpdev.h::MP3XOUTPUT_OPT" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> enum <a class="el" href="mpdev_8h.html#a81">MP3XOUTPUT_OPT</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Enumerated Values For MP36R/MP36AR Device Ouput modes. 
<p>
Represents supported MP36R/MP36AR output modes. <dl compact><dt><b>Enumeration values: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="anchor" name="a81a41" doxytag="OUTPUTVOLTAGELEVEL" ></a>OUTPUTVOLTAGELEVEL</em>&nbsp;</td><td>
= Setup ouptput mode to CONSTANT VOLTAGE LEVEL (MP36R/MP36AR does not support this mode) </td></tr>
<tr><td valign=top><em><a class="anchor" name="a81a42" doxytag="OUTPUTCHANNEL3" ></a>OUTPUTCHANNEL3</em>&nbsp;</td><td>
= Redirect input channel #3 to output </td></tr>
<tr><td valign=top><em><a class="anchor" name="a81a43" doxytag="OUTPUTCHANNEL1" ></a>OUTPUTCHANNEL1</em>&nbsp;</td><td>
= Redirect input channel #1 to output </td></tr>
<tr><td valign=top><em><a class="anchor" name="a81a44" doxytag="OUTPUTCHANNEL2" ></a>OUTPUTCHANNEL2</em>&nbsp;</td><td>
= Redirect input channel #2 to output </td></tr>
<tr><td valign=top><em><a class="anchor" name="a81a45" doxytag="OUTPUTCHANNEL4" ></a>OUTPUTCHANNEL4</em>&nbsp;</td><td>
= Redirect input channel #4 to output </td></tr>
<tr><td valign=top><em><a class="anchor" name="a81a46" doxytag="OUTPUTGROUND" ></a>OUTPUTGROUND</em>&nbsp;</td><td>
= Ground all output signal - setup output sugnal to zero level </td></tr>
</table>
</dl>
Definition at line <a class="el" href="mpdev_8h-source.html#l00109">109</a> of file <a class="el" href="mpdev_8h-source.html">mpdev.h</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a77" doxytag="mpdev.h::MP_COM_TYPE" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> enum <a class="el" href="mpdev_8h.html#a77">MP_COM_TYPE</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Enumerated Values for the MP Device Communication Types. 
<p>
Represents supported MP communication types. <dl compact><dt><b>Enumeration values: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="anchor" name="a77a12" doxytag="MPUSB" ></a>MPUSB</em>&nbsp;</td><td>
represents communication via USB </td></tr>
<tr><td valign=top><em><a class="anchor" name="a77a13" doxytag="MPUDP" ></a>MPUDP</em>&nbsp;</td><td>
represents communication via Ethernet using UDP </td></tr>
</table>
</dl>
Definition at line <a class="el" href="mpdev_8h-source.html#l00044">44</a> of file <a class="el" href="mpdev_8h-source.html">mpdev.h</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a80" doxytag="mpdev.h::MP_RETURN_CODE" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> enum <a class="el" href="mpdev_8h.html#a80">MP_RETURN_CODE</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Enumerated Return Code Values. 
<p>
Return codes that are generated by Hardware API functions. <dl compact><dt><b>Enumeration values: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="anchor" name="a80a22" doxytag="MPSUCCESS" ></a>MPSUCCESS</em>&nbsp;</td><td>
= successful execution </td></tr>
<tr><td valign=top><em><a class="anchor" name="a80a23" doxytag="MPDRVERR" ></a>MPDRVERR</em>&nbsp;</td><td>
= error communicating with the device drivers </td></tr>
<tr><td valign=top><em><a class="anchor" name="a80a24" doxytag="MPDLLBUSY" ></a>MPDLLBUSY</em>&nbsp;</td><td>
= a process is attached to the DLL, only one process may use the DLL </td></tr>
<tr><td valign=top><em><a class="anchor" name="a80a25" doxytag="MPINVPARA" ></a>MPINVPARA</em>&nbsp;</td><td>
= invalid parameter(s) </td></tr>
<tr><td valign=top><em><a class="anchor" name="a80a26" doxytag="MPNOTCON" ></a>MPNOTCON</em>&nbsp;</td><td>
= MP device is not connected </td></tr>
<tr><td valign=top><em><a class="anchor" name="a80a27" doxytag="MPREADY" ></a>MPREADY</em>&nbsp;</td><td>
= MP device is ready </td></tr>
<tr><td valign=top><em><a class="anchor" name="a80a28" doxytag="MPWPRETRIG" ></a>MPWPRETRIG</em>&nbsp;</td><td>
= MP device is waiting for pre-trigger (pre-triggering is not implemented) </td></tr>
<tr><td valign=top><em><a class="anchor" name="a80a29" doxytag="MPWTRIG" ></a>MPWTRIG</em>&nbsp;</td><td>
= MP device is waiting for trigger </td></tr>
<tr><td valign=top><em><a class="anchor" name="a80a30" doxytag="MPBUSY" ></a>MPBUSY</em>&nbsp;</td><td>
= MP device is busy </td></tr>
<tr><td valign=top><em><a class="anchor" name="a80a31" doxytag="MPNOACTCH" ></a>MPNOACTCH</em>&nbsp;</td><td>
= there are no active channels, in order to acquire data at least one analog channel must be active </td></tr>
<tr><td valign=top><em><a class="anchor" name="a80a32" doxytag="MPCOMERR" ></a>MPCOMERR</em>&nbsp;</td><td>
= generic communication error </td></tr>
<tr><td valign=top><em><a class="anchor" name="a80a33" doxytag="MPINVTYPE" ></a>MPINVTYPE</em>&nbsp;</td><td>
= the function is incompatible with the selected MP device or communication method </td></tr>
<tr><td valign=top><em><a class="anchor" name="a80a34" doxytag="MPNOTINNET" ></a>MPNOTINNET</em>&nbsp;</td><td>
= the specified MP150/MP160/MP200 is not in the network </td></tr>
<tr><td valign=top><em><a class="anchor" name="a80a35" doxytag="MPSMPLDLERR" ></a>MPSMPLDLERR</em>&nbsp;</td><td>
= MP device overwrote samples that had not been transferred from the device (buffer overflow) </td></tr>
<tr><td valign=top><em><a class="anchor" name="a80a36" doxytag="MPMEMALLOCERR" ></a>MPMEMALLOCERR</em>&nbsp;</td><td>
= error allocating memory </td></tr>
<tr><td valign=top><em><a class="anchor" name="a80a37" doxytag="MPSOCKERR" ></a>MPSOCKERR</em>&nbsp;</td><td>
= internal socket error </td></tr>
<tr><td valign=top><em><a class="anchor" name="a80a38" doxytag="MPUNDRFLOW" ></a>MPUNDRFLOW</em>&nbsp;</td><td>
= MP device returned a data pointer that is less than the last data pointer * </td></tr>
<tr><td valign=top><em><a class="anchor" name="a80a39" doxytag="MPPRESETERR" ></a>MPPRESETERR</em>&nbsp;</td><td>
= error with the specified preset file * </td></tr>
<tr><td valign=top><em><a class="anchor" name="a80a40" doxytag="MPPARSERERR" ></a>MPPARSERERR</em>&nbsp;</td><td>
= preset file parsing error, the XML file must be valid according to the schema * </td></tr>
</table>
</dl>
Definition at line <a class="el" href="mpdev_8h-source.html#l00081">81</a> of file <a class="el" href="mpdev_8h-source.html">mpdev.h</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a76" doxytag="mpdev.h::MP_TYPE" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> enum <a class="el" href="mpdev_8h.html#a76">MP_TYPE</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Enumerated Values for MP Devices. 
<p>
Represents supported MP devices. <dl compact><dt><b>Enumeration values: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="anchor" name="a76a7" doxytag="MP150" ></a>MP150</em>&nbsp;</td><td>
represents the MP150 device </td></tr>
<tr><td valign=top><em><a class="anchor" name="a76a8" doxytag="MP36" ></a>MP36</em>&nbsp;</td><td>
represents the MP36R device </td></tr>
<tr><td valign=top><em><a class="anchor" name="a76a9" doxytag="MP160" ></a>MP160</em>&nbsp;</td><td>
represents the MP160 device </td></tr>
<tr><td valign=top><em><a class="anchor" name="a76a10" doxytag="MP200" ></a>MP200</em>&nbsp;</td><td>
represents the MP200 device </td></tr>
<tr><td valign=top><em><a class="anchor" name="a76a11" doxytag="MP36A" ></a>MP36A</em>&nbsp;</td><td>
represents the MP36AR device </td></tr>
</table>
</dl>
Definition at line <a class="el" href="mpdev_8h-source.html#l00029">29</a> of file <a class="el" href="mpdev_8h-source.html">mpdev.h</a>.    </td>
  </tr>
</table>
<a class="anchor" name="a78" doxytag="mpdev.h::TRIGGER_OPT" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> enum <a class="el" href="mpdev_8h.html#a78">TRIGGER_OPT</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Enumerated Values For MP Device Triggering Options. 
<p>
Represents supported MP triggering options. <dl compact><dt><b>Enumeration values: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="anchor" name="a78a14" doxytag="MPTRIGOFF" ></a>MPTRIGOFF</em>&nbsp;</td><td>
represents triggering off </td></tr>
<tr><td valign=top><em><a class="anchor" name="a78a15" doxytag="MPTRIGEXT" ></a>MPTRIGEXT</em>&nbsp;</td><td>
represents external triggering </td></tr>
<tr><td valign=top><em><a class="anchor" name="a78a16" doxytag="MPTRIGACH" ></a>MPTRIGACH</em>&nbsp;</td><td>
represents analog channel triggering </td></tr>
<tr><td valign=top><em><a class="anchor" name="a78a17" doxytag="MPTRIGDCH" ></a>MPTRIGDCH</em>&nbsp;</td><td>
represents digital channel triggering (MP36R/MP36AR only) </td></tr>
</table>
</dl>
Definition at line <a class="el" href="mpdev_8h-source.html#l00055">55</a> of file <a class="el" href="mpdev_8h-source.html">mpdev.h</a>.    </td>
  </tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="a47" doxytag="mpdev.h::configChannelByPresetID" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> MPDLL_EXPORT <a class="el" href="mpdev_8h.html#a5">MPRETURNCODE</a> _stdcall configChannelByPresetID           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const DWORD&nbsp;</td>
          <td class="mdname" nowrap> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>uid</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Configure a Channel by Preset ID. 
<p>
This function will configure an analog input channel based on the preset element with the specified unique ID (uid) from the XML preset file loaded into memory using the <a class="el" href="mpdev_8h.html#a60">loadXMLPresetFile()</a> function.<p>
Please see <a class="el" href="chpresetxml_page.html">Channel Presets XML File</a>.<p>
<dl compact><dt><b>Note:</b></dt><dd><ul>
<li>For the MP36R/MP36AR, the Scaling and the Hardware Configuration elements are applied</li><li>For the MP150/MP160/MP200, only the Scaling element is applied</li></ul>
</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td></td><td valign=top><em>n</em>&nbsp;</td><td>the analog input channel where the preset configuration will be applied and 0 &lt;= <em>n</em> &lt; number of analog input channels of the MP device </td></tr>
    <tr><td></td><td valign=top><em>uid</em>&nbsp;</td><td>the unique identifier of the preset to be applied to the specified channels</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><em>MPRETURNCODE</em> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a48" doxytag="mpdev.h::connectMPDev" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> MPDLL_EXPORT <a class="el" href="mpdev_8h.html#a5">MPRETURNCODE</a> _stdcall connectMPDev           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="mpdev_8h.html#a1">MPTYPE</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>const <a class="el" href="mpdev_8h.html#a2">MPCOMTYPE</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>method</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>MP150SN</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Connect to the Specified MP Device. 
<p>
This function MUST be called first when using the Hardware API.<p>
<dl compact><dt><b>Note:</b></dt><dd><ul>
<li>This function will connnect to the first responding MP150, MP160 or MP200, when "AUTO" or "auto" is specified for the <em>MP150SN</em> parameter</li><li>The first responding MP150/MP160/MP200 is usually the closest MP150MP160/MP200 but it is not guaranteed</li><li>The MP150 serial number can be obtained using <a class="el" href="mpdev_8h.html#a52">findAllMP150()</a> and <a class="el" href="mpdev_8h.html#a61">readAvailableMP150SN()</a></li><li>The MP160 serial number can be obtained using <a class="el" href="mpdev_8h.html#a50">findAllMP160()</a> and <a class="el" href="mpdev_8h.html#a62">readAvailableMP160SN()</a></li><li>The MP200 serial number can be obtained using <a class="el" href="mpdev_8h.html#a51">findAllMP200()</a> and <a class="el" href="mpdev_8h.html#a63">readAvailableMP200SN()</a></li></ul>
</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td></td><td valign=top><em>type</em>&nbsp;</td><td>the type of device to connect with, must use <em>MPTYPE</em> enumerated values </td></tr>
    <tr><td></td><td valign=top><em>method</em>&nbsp;</td><td>the type of communication method, must use <em>MPCOMTYPE</em> enumerated values </td></tr>
    <tr><td></td><td valign=top><em>MP150SN</em>&nbsp;</td><td>can be set to any string if using the MP36R/MP36AR, otherwise it's the serial number of the MP150, MP160, MP200. "AUTO" or "auto" can be used to automatically connect to first MP150/MP160/MP200 to respond</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><em>MPRETURNCODE</em> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a49" doxytag="mpdev.h::disconnectMPDev" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> MPDLL_EXPORT <a class="el" href="mpdev_8h.html#a5">MPRETURNCODE</a> _stdcall disconnectMPDev           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Disconnect from the MP Device. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd><em>MPRETURNCODE</em> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a52" doxytag="mpdev.h::findAllMP150" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> MPDLL_EXPORT <a class="el" href="mpdev_8h.html#a5">MPRETURNCODE</a> _stdcall findAllMP150           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Find All MP150s. 
<p>
Finds all the MP150s routable in the current network configuration and caches their serial numbers which can be read by calling <a class="el" href="mpdev_8h.html#a61">readAvailableMP150SN()</a>.<p>
<dl compact><dt><b>Note:</b></dt><dd><ul>
<li><a class="el" href="mpdev_8h.html#a48">connectMPDev()</a> must be called first</li><li>the call to <a class="el" href="mpdev_8h.html#a48">connectMPDev()</a> must FAIL because of an invalid serial number</li><li>only works with device type <em>MP150</em> and communication type <em>MPUDP</em></li></ul>
</dd></dl>
<dl compact><dt><b>Returns:</b></dt><dd><em>MPRETURNCODE</em> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a50" doxytag="mpdev.h::findAllMP160" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> MPDLL_EXPORT <a class="el" href="mpdev_8h.html#a5">MPRETURNCODE</a> _stdcall findAllMP160           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Find All MP160s. 
<p>
Finds all the MP160s routable in the current network configuration and caches their serial numbers which can be read by calling <a class="el" href="mpdev_8h.html#a62">readAvailableMP160SN()</a>.<p>
<dl compact><dt><b>Note:</b></dt><dd><ul>
<li><a class="el" href="mpdev_8h.html#a48">connectMPDev()</a> must be called first</li><li>the call to <a class="el" href="mpdev_8h.html#a48">connectMPDev()</a> must FAIL because of an invalid serial number</li><li>only works with device type <em>MP160</em> and communication type <em>MPUDP</em></li></ul>
</dd></dl>
<dl compact><dt><b>Returns:</b></dt><dd><em>MPRETURNCODE</em> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a51" doxytag="mpdev.h::findAllMP200" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> MPDLL_EXPORT <a class="el" href="mpdev_8h.html#a5">MPRETURNCODE</a> _stdcall findAllMP200           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Find All MP200s. 
<p>
Finds all the MP200s routable in the current network configuration and caches their serial numbers which can be read by calling <a class="el" href="mpdev_8h.html#a63">readAvailableMP200SN()</a>.<p>
<dl compact><dt><b>Note:</b></dt><dd><ul>
<li><a class="el" href="mpdev_8h.html#a48">connectMPDev()</a> must be called first</li><li>the call to <a class="el" href="mpdev_8h.html#a48">connectMPDev()</a> must FAIL because of an invalid serial number</li><li>only works with device type <em>MP200</em> and communication type <em>MPUDP</em></li></ul>
</dd></dl>
<dl compact><dt><b>Returns:</b></dt><dd><em>MPRETURNCODE</em> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a53" doxytag="mpdev.h::getChScaledInputRange" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> MPDLL_EXPORT <a class="el" href="mpdev_8h.html#a5">MPRETURNCODE</a> _stdcall getChScaledInputRange           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const DWORD&nbsp;</td>
          <td class="mdname" nowrap> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>minRange</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>maxRange</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get a Channel's Scaled Input Range. 
<p>
This function calculates the scaled input range of a particular channel. The Scaled Input Range is the scaled range of double values where the MP device can successfully read a scaled sample value without clipping. It is depedent upon scaling, gain, and offset values of the specified analog input channel. If the scaled sample value is out of the range, it will be clipped to the range's maximum or minimum value.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td></td><td valign=top><em>n</em>&nbsp;</td><td>the analog input channel where the scaled channel input range will be calculated and 0 &lt;= <em>n</em> &lt; number of analog input channels of the MP device </td></tr>
    <tr><td></td><td valign=top><em>minRange</em>&nbsp;</td><td>an out variable where the minimum value of the scaled input range is stored </td></tr>
    <tr><td></td><td valign=top><em>maxRange</em>&nbsp;</td><td>an out variable where the maximum value of the scaled input range is stored</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><em>MPRETURNCODE</em> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a54" doxytag="mpdev.h::getDigitalIO" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> MPDLL_EXPORT <a class="el" href="mpdev_8h.html#a5">MPRETURNCODE</a> _stdcall getDigitalIO           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const DWORD&nbsp;</td>
          <td class="mdname" nowrap> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>BOOL *&nbsp;</td>
          <td class="mdname" nowrap> <em>state</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>const <a class="el" href="mpdev_8h.html#a4">DIGITALOPT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>opt</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the State of the Specified Digital I/O Line. 
<p>
<em>true</em> = "high" = 1 = 5.0 volts (TTL high) <br>
 <em>false</em> = "low" = 0 = 0.0 volts (TTL low)<p>
<dl compact><dt><b>Note:</b></dt><dd><ul>
<li>The MP36R/MP36AR has dedicated input and output lines while the MP150/MP160/MP200 has auto-switching digital input and output lines</li><li>For the MP150/MP160/MP200, this function automatically switches the direction of all the Digital I/O lines to input</li><li>The MP36R/MP36AR has 8 digital input lines (digital lines 0 through 7)</li><li>The MP150/MP160/MP200 has 16 digital input lines (digital lines 0 through 15)</li></ul>
</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td></td><td valign=top><em>n</em>&nbsp;</td><td>the Digital Input channel to get where 0 &lt;= <em>n</em> &lt; number of digital input channels of the MP device </td></tr>
    <tr><td></td><td valign=top><em>state</em>&nbsp;</td><td>an out variable where the state of Digital Input line <em>n</em> is stored </td></tr>
    <tr><td></td><td valign=top><em>opt</em>&nbsp;</td><td>if <em>opt</em> == <em>READ_LOW_BITS</em> and 0 &lt;= <em>n</em> &lt; 8 only digital lines 0-7 are read<br>
 if <em>opt</em> == <em>READ_HIGH_BITS</em> and 8 &lt;= <em>n</em> &lt; 16 only digital lines 8-15 are read<br>
</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><em>MPRETURNCODE</em> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a55" doxytag="mpdev.h::getElectrodeCheckImpedance" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> MPDLL_EXPORT <a class="el" href="mpdev_8h.html#a5">MPRETURNCODE</a> _stdcall getElectrodeCheckImpedance           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double *&nbsp;</td>
          <td class="mdname" nowrap> <em>redImpedance</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>whiteImpedance</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the current measured resistances from the electrode checker. 
<p>
This function instructs the MP36R/MP36AR unit to perform an impedance measurement on the leads attached to the Electrode Checker port on the front of the MP36R/MP36AR unit. This measures the impedance between the red and white electrode lead and the ground electrode. Lower impedances indicate better electrode contact with the skin. Only MP36R/MP36AR units support using the electrode checker.<p>
<dl compact><dt><b>Note:</b></dt><dd><ul>
<li>MP150, MP160, MP200 units will return an error</li><li>On the MP36R/MP36AR electrodes must disconnected from the analog input channel and connected to the electrode checker port to be checked. Software should prompt the user to re-connect the electrode leads to the appropriate analog input channel</li><li>Electrode cannot be performed while an acquisition is in progress</li></ul>
</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td></td><td valign=top><em>redImpedance</em>&nbsp;</td><td>set to the impedance between the RED lead and ground in kOhm, or -1 if the electrode checker is off, unavailable, or no electrode contact is detected </td></tr>
    <tr><td></td><td valign=top><em>whiteImpedance</em>&nbsp;</td><td>set to the impedance between the WHITE lead and ground in kOhm, or -1 if the electrode checker is off, unavailable, or no electrode contact is detected </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><em>MPRETURNCODE</em> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a56" doxytag="mpdev.h::getMostRecentSample" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> MPDLL_EXPORT <a class="el" href="mpdev_8h.html#a5">MPRETURNCODE</a> _stdcall getMostRecentSample           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>data</em>[]          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the Most Recent Sample. 
<p>
This function blocks until the MP device acquires the most recent sample. Once <a class="el" href="mpdev_8h.html#a73">startAcquisition()</a> is called, the MP device continuously acquires data at the specified sample rate. Use this function to get the latest sample collected at the time it was called. This function is useful in monitoring purposes at low sample rates where previous data does not change rapidly.<p>
<dl compact><dt><b>Note:</b></dt><dd><ul>
<li>If acquiring only analog input channels:<ul>
<li><em>data</em> array must be able to hold double values equivalent to number of analog input channels of the MP device</li><li>After this function is succesfully invoked, data[<em>i</em>] = the most recent sample of the Analog Input Channel <em>i</em>+1, where 0 &lt;= <em>i</em> &lt; the number of analog input channels of the MP device</li><li>If a channel is not enabled for acquisition the corresponding array element will not be set to a default value</li></ul>
</li><li>If acquiring analog and digital channels:<ul>
<li><em>data</em> array must be able to hold double values equivalent to number of analog input channels plus the number of digital input channels of the MP device</li><li>After this function is succesfully invoked, data[<em>i</em>] = the most recent sample of the Analog Input Channel <em>i</em>+1 and data[<em>a+d</em>] = the most recent sample of the Digital Input Channel <em>a+d</em> where:<ul>
<li><em>a</em> is the number of analog input channels of the MP device</li><li>0 &lt;= <em>i</em> &lt; <em>a</em></li><li>0 &lt;= <em>d</em> &lt; the number of digital input channels of the MP device</li></ul>
</li><li>If a channel is not enabled for acquisition the corresponding array element will not be set to a default value</li></ul>
</li></ul>
</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td></td><td valign=top><em>data</em>&nbsp;</td><td>an out double array variable where the most recent sample for input channels is stored by the function</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><em>MPRETURNCODE</em> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a57" doxytag="mpdev.h::getMPBuffer" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> MPDLL_EXPORT <a class="el" href="mpdev_8h.html#a5">MPRETURNCODE</a> _stdcall getMPBuffer           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const DWORD&nbsp;</td>
          <td class="mdname" nowrap> <em>numSamples</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>buff</em>[]</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the Acquisition Buffer. 
<p>
This function blocks until the MP device acquires the number of samples requested. The values will be interleaved, which means that the value for each active channel will be adjacent to each other and in increasing order by channel number. If acquiring with analog and digital channels, data from active digitals channels will follow the analog channels in the same interleaved manner.<p>
This function should only be used for acquisitions lasting less than a minute. <b>It must only be called once per acquisition.</b><p>
<dl compact><dt><b></b></dt><dd><p>
If the MP device is set to acquire data on Analog CH3, Analog CH5 and Analog CH7 for 2 samples, the buffer will look like as follows:
</p>
<table cellspacing="0" cellpadding="0" align="center" border="1">
<tr align="center"><td colspan="3">First Sample</td><td colspan="3">Second Sample</td></tr>
<tr align="center"><td>Analog CH3</td><td>Analog CH5</td><td>Analog CH7</td><td>Analog CH3</td><td>Analog CH5</td><td>Analog CH7</td>
</table>
<p> 
Notice that values for Analog CH1, Analog CH2, Analog CH4, Analog CH6, and Analog CH8 through Analog CH16 are not recorded in the buffer.
</p>
<p>
If the MP device is set to acquire data on Analog CH1, Analog CH3, Digital CH0 and Digital CH3 for 4 samples, the buffer will look as follows:
</p>
<table cellspacing="0" cellpadding="0" align="center" border="1">
<tr align="center"><td colspan="4">First Sample</td><td colspan="4">Second Sample</td><td colspan="4">Third Sample</td><td colspan="4">Fourth Sample</td></tr>
<tr align="center"><td>Analog CH1</td><td>Analog CH3</td><td>Digital CH0</td><td>Digital CH3</td><td>Analog CH1</td><td>Analog CH3</td><td>Digital CH0</td><td>Digital CH3</td><td>Analog CH1</td><td>Analog CH3</td><td>Digital CH0</td><td>Digital CH3</td><td>Analog CH1</td><td>Analog CH3</td><td>Digital CH0</td><td>Digital CH3</td></tr>
</table>

</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd><ul>
<li><em>buff</em> array must be able to hold at least <em>numSamples*(number of active analog channels + number of active digital channels )</em> double values</li></ul>
</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td></td><td valign=top><em>numSamples</em>&nbsp;</td><td>the number of samples to acquire </td></tr>
    <tr><td></td><td valign=top><em>buff</em>&nbsp;</td><td>an out double array variable where values from the acquisition are stored</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><em>MPRETURNCODE</em> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a58" doxytag="mpdev.h::getMPDaemonLastError" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> MPDLL_EXPORT <a class="el" href="mpdev_8h.html#a5">MPRETURNCODE</a> _stdcall getMPDaemonLastError           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the MP Daemon Last Error. 
<p>
This function returns the exit value or the status of the MP Acquisition Daemon that was created by a call to <a class="el" href="mpdev_8h.html#a74">startMPAcqDaemon()</a>.<p>
<dl compact><dt><b>Returns:</b></dt><dd><em>MPRETURNCODE</em> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a59" doxytag="mpdev.h::getStatusMPDev" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> MPDLL_EXPORT <a class="el" href="mpdev_8h.html#a5">MPRETURNCODE</a> _stdcall getStatusMPDev           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the Status of the MP Device. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd><em>MPRETURNCODE</em> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a60" doxytag="mpdev.h::loadXMLPresetFile" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> MPDLL_EXPORT <a class="el" href="mpdev_8h.html#a5">MPRETURNCODE</a> _stdcall loadXMLPresetFile           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>filename</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Load an XML Preset File. 
<p>
This function loads an XML preset file into memory. The XML document must be properly formatted.<p>
Please see <a class="el" href="chpresetxml_page.html">Channel Presets XML File</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td></td><td valign=top><em>filename</em>&nbsp;</td><td>the complete filename of the XML file using absolute or relative path</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><em>MPRETURNCODE</em> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a61" doxytag="mpdev.h::readAvailableMP150SN" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> MPDLL_EXPORT <a class="el" href="mpdev_8h.html#a5">MPRETURNCODE</a> _stdcall readAvailableMP150SN           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">char&nbsp;</td>
          <td class="mdname" nowrap> <em>buff</em>[], </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>const DWORD&nbsp;</td>
          <td class="mdname" nowrap> <em>numchartoread</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>DWORD *&nbsp;</td>
          <td class="mdname" nowrap> <em>numcharread</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Read the Serial Numbers of Available MP150s. 
<p>
Reads the serial numbers of MP150s routable in the current network configuration.<p>
<dl compact><dt><b>Note:</b></dt><dd><ul>
<li>requires a successful call to <a class="el" href="mpdev_8h.html#a52">findAllMP150()</a></li><li>MP150 serial number normally consist of 12 characters</li><li>each line represents the serial number of a MP150</li><li>each line will normally consist of 13 characters (the serial number and the newline character, '\n')</li><li>returns <em>MPSUCCESS</em> if it reads one or more characters</li><li><em>buff</em> array must be able to hold at least <em>numchartoread</em> character values</li></ul>
</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td></td><td valign=top><em>buff</em>&nbsp;</td><td>an out array variable where the number of requested character to read will be stored </td></tr>
    <tr><td></td><td valign=top><em>numchartoread</em>&nbsp;</td><td>the number of characters requested to be read </td></tr>
    <tr><td></td><td valign=top><em>numcharread</em>&nbsp;</td><td>an out variable where the number of characters actually read is stored</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><em>MPRETURNCODE</em></dd></dl>
<div class="fragment"><pre>

<a class="code" href="mpdev_8h.html#a48">connectMPDev</a>(MP150, MPUDP, <span class="stringliteral">"bad SN"</span>);
                
<a class="code" href="mpdev_8h.html#a52">findAllMP150</a>();
<span class="keywordtype">char</span> sn[16];
                
DWORD readtest;
                
<span class="keywordflow">while</span>(<a class="code" href="mpdev_8h.html#a61">readAvailableMP150SN</a>(sn, 12, &amp;readtest) == <a class="code" href="mpdev_8h.html#a80a22">MPSUCCESS</a>)
{
        sn[readtest] = <span class="charliteral">'\0'</span>; <span class="comment">//null terminate strings</span>
        printf(<span class="stringliteral">"%s"</span>,sn);
}

</pre></div>     </td>
  </tr>
</table>
<a class="anchor" name="a62" doxytag="mpdev.h::readAvailableMP160SN" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> MPDLL_EXPORT <a class="el" href="mpdev_8h.html#a5">MPRETURNCODE</a> _stdcall readAvailableMP160SN           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">char&nbsp;</td>
          <td class="mdname" nowrap> <em>buff</em>[], </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>const DWORD&nbsp;</td>
          <td class="mdname" nowrap> <em>numchartoread</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>DWORD *&nbsp;</td>
          <td class="mdname" nowrap> <em>numcharread</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Read the Serial Numbers of Available MP160s. 
<p>
Reads the serial numbers of MP160s routable in the current network configuration.<p>
<dl compact><dt><b>Note:</b></dt><dd><ul>
<li>requires a successful call to <a class="el" href="mpdev_8h.html#a50">findAllMP160()</a></li><li>MP160 serial number normally consist of 12 characters</li><li>each line represents the serial number of a MP160</li><li>each line will normally consist of 13 characters (the serial number and the newline character, '\n')</li><li>returns <em>MPSUCCESS</em> if it reads one or more characters</li><li><em>buff</em> array must be able to hold at least <em>numchartoread</em> character values</li></ul>
</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td></td><td valign=top><em>buff</em>&nbsp;</td><td>an out array variable where the number of requested character to read will be stored </td></tr>
    <tr><td></td><td valign=top><em>numchartoread</em>&nbsp;</td><td>the number of characters requested to be read </td></tr>
    <tr><td></td><td valign=top><em>numcharread</em>&nbsp;</td><td>an out variable where the number of characters actually read is stored</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><em>MPRETURNCODE</em></dd></dl>
<div class="fragment"><pre>

<a class="code" href="mpdev_8h.html#a48">connectMPDev</a>(MP150, MPUDP, <span class="stringliteral">"bad SN"</span>);
                
<a class="code" href="mpdev_8h.html#a52">findAllMP150</a>();
<span class="keywordtype">char</span> sn[16];
                
DWORD readtest;
                
<span class="keywordflow">while</span>(<a class="code" href="mpdev_8h.html#a61">readAvailableMP150SN</a>(sn, 12, &amp;readtest) == <a class="code" href="mpdev_8h.html#a80a22">MPSUCCESS</a>)
{
        sn[readtest] = <span class="charliteral">'\0'</span>; <span class="comment">//null terminate strings</span>
        printf(<span class="stringliteral">"%s"</span>,sn);
}

</pre></div>     </td>
  </tr>
</table>
<a class="anchor" name="a63" doxytag="mpdev.h::readAvailableMP200SN" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> MPDLL_EXPORT <a class="el" href="mpdev_8h.html#a5">MPRETURNCODE</a> _stdcall readAvailableMP200SN           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">char&nbsp;</td>
          <td class="mdname" nowrap> <em>buff</em>[], </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>const DWORD&nbsp;</td>
          <td class="mdname" nowrap> <em>numchartoread</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>DWORD *&nbsp;</td>
          <td class="mdname" nowrap> <em>numcharread</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Read the Serial Numbers of Available MP200s. 
<p>
Reads the serial numbers of MP200s routable in the current network configuration.<p>
<dl compact><dt><b>Note:</b></dt><dd><ul>
<li>requires a successful call to <a class="el" href="mpdev_8h.html#a51">findAllMP200()</a></li><li>MP200 serial number normally consist of 12 characters</li><li>each line represents the serial number of a MP200</li><li>each line will normally consist of 13 characters (the serial number and the newline character, '\n')</li><li>returns <em>MPSUCCESS</em> if it reads one or more characters</li><li><em>buff</em> array must be able to hold at least <em>numchartoread</em> character values</li></ul>
</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td></td><td valign=top><em>buff</em>&nbsp;</td><td>an out array variable where the number of requested character to read will be stored </td></tr>
    <tr><td></td><td valign=top><em>numchartoread</em>&nbsp;</td><td>the number of characters requested to be read </td></tr>
    <tr><td></td><td valign=top><em>numcharread</em>&nbsp;</td><td>an out variable where the number of characters actually read is stored</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><em>MPRETURNCODE</em></dd></dl>
<div class="fragment"><pre>

<a class="code" href="mpdev_8h.html#a48">connectMPDev</a>(MP150, MPUDP, <span class="stringliteral">"bad SN"</span>);
                
<a class="code" href="mpdev_8h.html#a52">findAllMP150</a>();
<span class="keywordtype">char</span> sn[16];
                
DWORD readtest;
                
<span class="keywordflow">while</span>(<a class="code" href="mpdev_8h.html#a61">readAvailableMP150SN</a>(sn, 12, &amp;readtest) == <a class="code" href="mpdev_8h.html#a80a22">MPSUCCESS</a>)
{
        sn[readtest] = <span class="charliteral">'\0'</span>; <span class="comment">//null terminate strings</span>
        printf(<span class="stringliteral">"%s"</span>,sn);
}

</pre></div>     </td>
  </tr>
</table>
<a class="anchor" name="a64" doxytag="mpdev.h::receiveMPData" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> MPDLL_EXPORT <a class="el" href="mpdev_8h.html#a5">MPRETURNCODE</a> _stdcall receiveMPData           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double&nbsp;</td>
          <td class="mdname" nowrap> <em>buff</em>[], </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>const DWORD&nbsp;</td>
          <td class="mdname" nowrap> <em>numdatapoints</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>DWORD *&nbsp;</td>
          <td class="mdname" nowrap> <em>numreceived</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Receive the MP Data. 
<p>
Receives the MP data from the MP Acquisition Daemon. This is recommended for continuous acquisitions. The values will be interleaved, which means that the value for each active channel will be adjacent to each other and in increasing order by channel number. If acquiring with analog and digital channels, data from active digitals channels will follow the analog channels in the same interleaved manner.<p>
<p>
If the MP device is set to acquire data on Analog CH3, Analog CH5 and Analog CH7 where ACH<em>N</em>S<em>I</em> is the value of Analog Channel <em>N</em> at sample <em>I</em>:
</p>

<table cellspacing="0" cellpadding="0" align="center" border="1">
<tr align="center"><td>ACH3S1</td><td>ACH5S1</td><td>ACH7S1</td><td>ACH3S2</td><td>ACH5S2</td><td>ACH7S2</td><td>ACH3S3</td><td>ACH5S3</td><td>ACH7S3</td><td>ACH3S4</td><td>ACH5S4</td><td>ACH7S4</td><td>ACH3S5</td><td>...</td><td>...</td><td>...</td><td>...</td><td>...</td>
</table>

<p>
If the MP device is set to acquire data on Analog CH3, Digital CH0 and Digital CH5 where ACH<em>N</em>S<em>I</em> is the value of Analog Channel <em>N</em> at sample <em>I</em> and DCH<em>N</em>S<em>I</em> is the value of Digital Channel <em>N</em> at sample <em>I</em>:
</p>

<table cellspacing="0" cellpadding="0" align="center" border="1">
<tr align="center"><td>ACH3S1</td><td>DCH0S1</td><td>DCH5S1</td><td>ACH3S2</td><td>DCH0S2</td><td>DCH5S2</td><td>ACH3S3</td><td>DCH0S3</td><td>DCH5S3</td><td>ACH3S4</td><td>DCH0S4</td><td>DCH5S4</td><td>ACH3S5</td><td>DCH0S5</td><td>...</td><td>...</td><td>...</td><td>...</td>
</table>
<p>
<dl compact><dt><b>Note:</b></dt><dd><ul>
<li>requires a successful call to <a class="el" href="mpdev_8h.html#a74">startMPAcqDaemon()</a></li><li>the data will be a stream of double values</li><li>returns <em>MPSUCCESS</em> if it receives one or more double values</li><li><em>buff</em> array must be able to hold at least <em>numdatapoints</em> double values</li></ul>
</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td></td><td valign=top><em>buff</em>&nbsp;</td><td>an out array variable where the number of requested double values to receive will be stored </td></tr>
    <tr><td></td><td valign=top><em>numdatapoints</em>&nbsp;</td><td>the number of values requested to be received from the acquisition daemon </td></tr>
    <tr><td></td><td valign=top><em>numreceived</em>&nbsp;</td><td>an out variable where the number of double values actually received from the acquisition daemon is stored</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><em>MPRETURNCODE</em></dd></dl>
<div class="fragment"><pre>

<span class="comment">// Start Acquisition Daemon Demo</span>
<span class="keywordtype">void</span> startAcqDaemonDemo()
{
        <a class="code" href="mpdev_8h.html#a5">MPRETURNCODE</a> retval;

        <span class="comment">//acquire on channel 2, 7, and 11</span>
        BOOL analogCH[] = {<span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>,
                                           <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>,
                                           <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>,
                                           <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>};

        cout &lt;&lt; <span class="stringliteral">"Acquire data on  Analog Channel 1 and Analog Channel 5"</span> 
                 &lt;&lt; endl;
        cout &lt;&lt; <span class="stringliteral">"Setting Acquisition Channels..."</span> 
                 &lt;&lt; endl;
        retval = <a class="code" href="mpdev_8h.html#a65">setAcqChannels</a>(analogCH);

        <span class="keywordflow">if</span>(retval != <a class="code" href="mpdev_8h.html#a80a22">MPSUCCESS</a>)
        {
                cout &lt;&lt; <span class="stringliteral">"Program failed to set Acquisition Channels"</span> 
                         &lt;&lt; endl;
                cout &lt;&lt; <span class="stringliteral">"setAcqChannels(...) returned with "</span> 
                         &lt;&lt; retval &lt;&lt; <span class="stringliteral">" as a return code."</span> &lt;&lt; endl;

                <span class="keywordflow">return</span>;
        }

        <span class="comment">//set sample rate to 5 msec per sample = 200 Hz</span>
        cout &lt;&lt; <span class="stringliteral">"Setting Sample Rate to 200 Hz"</span> &lt;&lt; endl;
        retval = <a class="code" href="mpdev_8h.html#a72">setSampleRate</a>(5.0);

        <span class="keywordflow">if</span>(retval != <a class="code" href="mpdev_8h.html#a80a22">MPSUCCESS</a>)
        {
                cout &lt;&lt; <span class="stringliteral">"Program failed to set Sample Rate"</span>
                         &lt;&lt; endl;
                cout &lt;&lt; <span class="stringliteral">"setSampleRate(...) returned with "</span> &lt;&lt; retval 
                         &lt;&lt; <span class="stringliteral">" as a return code."</span> &lt;&lt; endl;

                <span class="keywordflow">return</span>;
        }

        cout &lt;&lt; <span class="stringliteral">"Starting Acquisition Daemon..."</span> &lt;&lt; endl;
        retval =  <a class="code" href="mpdev_8h.html#a74">startMPAcqDaemon</a>();

        <span class="keywordflow">if</span>(retval != <a class="code" href="mpdev_8h.html#a80a22">MPSUCCESS</a>)
        {
                cout &lt;&lt; <span class="stringliteral">"Program failed to Start Acquisition Daemon"</span> 
                         &lt;&lt; endl;
                cout &lt;&lt; <span class="stringliteral">"startMPAcqDaemon() returned with "</span> 
                         &lt;&lt; retval &lt;&lt; <span class="stringliteral">" as a return code."</span> &lt;&lt; endl;

                cout &lt;&lt; <span class="stringliteral">"Stopping..."</span> &lt;&lt; endl;

                <a class="code" href="mpdev_8h.html#a75">stopAcquisition</a>();
                
                <span class="keywordflow">return</span>;
        }

        cout &lt;&lt; <span class="stringliteral">"Daemon Started"</span> &lt;&lt; endl;

        cout &lt;&lt; <span class="stringliteral">"Starting Acquisition..."</span> &lt;&lt; endl;
        retval = <a class="code" href="mpdev_8h.html#a73">startAcquisition</a>();

        <span class="keywordflow">if</span>(retval != <a class="code" href="mpdev_8h.html#a80a22">MPSUCCESS</a>)
        {
                cout &lt;&lt; <span class="stringliteral">"Program failed to Start Acquisition"</span> 
                         &lt;&lt; endl;
                cout &lt;&lt; <span class="stringliteral">"startAcquisition() returned with "</span> 
                         &lt;&lt; retval &lt;&lt; <span class="stringliteral">" as a return code."</span> &lt;&lt; endl;

                cout &lt;&lt; <span class="stringliteral">"Stopping..."</span> &lt;&lt; endl;

                <a class="code" href="mpdev_8h.html#a75">stopAcquisition</a>();

                <span class="keywordflow">return</span>;
        }

        cout &lt;&lt; <span class="stringliteral">"Acquiring..."</span> &lt;&lt; endl;

        <span class="keywordtype">long</span> numsamples = 5000;

        cout &lt;&lt; <span class="stringliteral">"Getting "</span> &lt;&lt; numsamples 
             &lt;&lt; <span class="stringliteral">" samples from the MP device... "</span> 
                 &lt;&lt; endl;
        
        DWORD valuesRead = 0;
        DWORD numValuesToRead = 0;
        <span class="comment">//remember that data will be interleaved</span>
        <span class="comment">//therefore you need to mulitply the number of samples</span>
        <span class="comment">//by the number of active channels to acquire the necessary</span>
        <span class="comment">//data points from the active channels</span>
        DWORD remainValues = 3*numsamples;
        <span class="keywordtype">double</span> * buff = <span class="keyword">new</span> <span class="keywordtype">double</span>[remainValues];
        DWORD offset = 0;

        cout &lt;&lt; <span class="stringliteral">"Acquiring...\n"</span> &lt;&lt; endl;

        <span class="keywordflow">while</span>(remainValues &gt; 0)
        {
           <span class="comment">//read 1 second of data at a time</span>
           <span class="comment">//frequency times the number of active channels</span>
           numValuesToRead = 3*200;

           <span class="comment">//if there are more values to be read than the remaining </span>
           <span class="comment">//number of values you want read, then just read the reamining needed</span>
           numValuesToRead = (numValuesToRead &gt; remainValues) ? remainValues : numValuesToRead;

          
           <span class="keywordflow">if</span>(<a class="code" href="mpdev_8h.html#a64">receiveMPData</a>(buff+offset,numValuesToRead, &amp;valuesRead) != <a class="code" href="mpdev_8h.html#a80a22">MPSUCCESS</a>)
           {
                   cout &lt;&lt; <span class="stringliteral">"Failed to receive MP data"</span> &lt;&lt; endl;

                   <a class="code" href="mpdev_8h.html#a75">stopAcquisition</a>();
        
                   <span class="keywordflow">break</span>;
           }

           offset += numValuesToRead;
           remainValues -= numValuesToRead;

           <span class="comment">//show status</span>
           printf(<span class="stringliteral">"                                                      \r"</span>);
           printf(<span class="stringliteral">"Remaining Values: %d\r"</span>, remainValues );
        }

        cout &lt;&lt; endl;

        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0; j&lt;numsamples; j++)
        {
                cout &lt;&lt; <span class="stringliteral">"Sample: "</span> &lt;&lt; j+1 &lt;&lt; endl;
                
                <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i &lt; 3; i++)
                        <span class="keywordflow">switch</span>(i)
                        {
                                <span class="keywordflow">case</span> 0:
                                        cout &lt;&lt; <span class="stringliteral">"CH2: "</span> &lt;&lt; buff[i+(3*j)];
                                        <span class="keywordflow">break</span>;
                                <span class="keywordflow">case</span> 1:
                                        cout &lt;&lt; <span class="stringliteral">" CH7: "</span> &lt;&lt; buff[i+(3*j)];
                                        <span class="keywordflow">break</span>;
                                <span class="keywordflow">case</span> 2:
                                        cout &lt;&lt; <span class="stringliteral">" CH11: "</span> &lt;&lt; buff[i+(3*j)] &lt;&lt; endl;
                                        <span class="keywordflow">break</span>;
                                <span class="keywordflow">default</span>:
                                        <span class="keywordflow">break</span>;
                                
                        }
        }

        <span class="comment">//stop</span>
        cout &lt;&lt; <span class="stringliteral">"Stopping..."</span> &lt;&lt; endl;

        <a class="code" href="mpdev_8h.html#a75">stopAcquisition</a>();

        <span class="comment">//free memory</span>
        <span class="keyword">delete</span>[] buff;
}

</pre></div>     </td>
  </tr>
</table>
<a class="anchor" name="a65" doxytag="mpdev.h::setAcqChannels" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> MPDLL_EXPORT <a class="el" href="mpdev_8h.html#a5">MPRETURNCODE</a> _stdcall setAcqChannels           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const BOOL&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>analogCH</em>[]          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the Analog Channels to Acquire. 
<p>
In order for data acquisition to start, at least one analog channel must be enabled for acquisition.<p>
analogCH[<em>i</em>] = <em>true</em> implies that the MP device is set to acquire from Analog Channel <em>i</em>+1. <br>
 analogCH[<em>i</em>] = <em>false</em> implies that the MP device will be ignoring any data from Analog Channel <em>i</em>+1. <br>
 Where 0 &lt;= <em>i</em> &lt; number of analog input channels of the MP device.<p>
<dl compact><dt><b>Note:</b></dt><dd><ul>
<li>The length of <em>analgoCH</em> array must equal to the number of analog input channels of the MP device</li></ul>
</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td></td><td valign=top><em>analogCH</em>&nbsp;</td><td>an array of booleans, which enables/disables acquisition on the corresponding analog input channel</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><em>MPRETURNCODE</em> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a66" doxytag="mpdev.h::setAnalogChScale" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> MPDLL_EXPORT <a class="el" href="mpdev_8h.html#a5">MPRETURNCODE</a> _stdcall setAnalogChScale           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const DWORD&nbsp;</td>
          <td class="mdname" nowrap> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>const double&nbsp;</td>
          <td class="mdname" nowrap> <em>unscaled1</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>const double&nbsp;</td>
          <td class="mdname" nowrap> <em>scaled1</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>const double&nbsp;</td>
          <td class="mdname" nowrap> <em>unscaled2</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>const double&nbsp;</td>
          <td class="mdname" nowrap> <em>scaled2</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the Analog Channel Scaling. 
<p>
This function configures the linear scaling of the specified analog input channel. It determines the linear scaling and offset values using the two pairs of unscaled and scaled values. The linear scaling and offset are then applied to unscaled values read from the MP device internally. These scaled values are what is returned by the <a class="el" href="mpdev_8h.html#a56">getMostRecentSample()</a>, <a class="el" href="mpdev_8h.html#a57">getMPBuffer()</a>, and <a class="el" href="mpdev_8h.html#a64">receiveMPData()</a> functions.<p>
<dl compact><dt><b>Note:</b></dt><dd><ul>
<li>The usnscaled values are in the units of voltage, the native units of the MP device</li><li>The default scaling factor for analog input channels is one with an offset of zero</li></ul>
</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td></td><td valign=top><em>n</em>&nbsp;</td><td>the analog input channel where the scaling configuration will be applied and 0 &lt;= <em>n</em> &lt; number of analog input channels of the MP device </td></tr>
    <tr><td></td><td valign=top><em>unscaled1</em>&nbsp;</td><td>the first unscaled voltage value </td></tr>
    <tr><td></td><td valign=top><em>scaled1</em>&nbsp;</td><td>the first scaled value </td></tr>
    <tr><td></td><td valign=top><em>unscaled2</em>&nbsp;</td><td>the second unscaled voltage value </td></tr>
    <tr><td></td><td valign=top><em>scaled2</em>&nbsp;</td><td>the second scaled value</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><em>MPRETURNCODE</em> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a67" doxytag="mpdev.h::setAnalogOut" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> MPDLL_EXPORT <a class="el" href="mpdev_8h.html#a5">MPRETURNCODE</a> _stdcall setAnalogOut           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const double&nbsp;</td>
          <td class="mdname" nowrap> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>outchan</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the Voltage of the Specified Analog Output Channel. 
<p>
<dl compact><dt><b>Note:</b></dt><dd><ul>
<li>For the MP150/MP160/MP200, <em>maxvolt</em> = 10.0 and <em>minvolt</em> = -10.0</li><li>For the MP36R/MP36AR, constant voltage level output is not supported</li></ul>
</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td></td><td valign=top><em>value</em>&nbsp;</td><td>voltage to set the specific analog output channel, <em>minvolt</em> &lt;= <em>value</em> &lt;= <em>maxvolt</em> </td></tr>
    <tr><td></td><td valign=top><em>outchan</em>&nbsp;</td><td>specify the output channel number, <em>outchan</em> = 1 or <em>outchan</em> = 0</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><em>MPRETURNCODE</em></dd></dl>
<dl compact><dt><b>Warning:</b></dt><dd>For safety, always set analog output channels back to zero volts before the client program exits or physically power cycle the MP device. If you do not set the voltage level back to zero the analog output channels may continue to output a non-zero voltage. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a68" doxytag="mpdev.h::setAnalogOutputMode" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> MPDLL_EXPORT <a class="el" href="mpdev_8h.html#a5">MPRETURNCODE</a> _stdcall setAnalogOutputMode           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="mpdev_8h.html#a6">MP3XOUTMODE</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>mode</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Setup output mode for MP device. 
<p>
<dl compact><dt><b>Note:</b></dt><dd><ul>
<li>Allow switching to different output modes of MP devices</li><li>One of MP36R/MP36AR Input channels may be redirected to Output Channel 0</li><li>to reset output signal to zero user should issue this command with parameter of OUTPUTGROUND</li></ul>
</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td></td><td valign=top><em>mode</em>&nbsp;</td><td>specify the output mode of MP36R/MP36AR device<br>
 if <em>mode</em> == <em>OUTPUTCHANNEL1</em> Redirect signal of Input channel #1 to Analog Output Channel 0<br>
 if <em>mode</em> == <em>OUTPUTCHANNEL2</em> Redirect signal of Input channel #2 to Analog Output Channel 0<br>
 if <em>mode</em> == <em>OUTPUTCHANNEL3</em> Redirect signal of Input channel #3 to Analog Output Channel 0<br>
 if <em>mode</em> == <em>OUTPUTCHANNEL4</em> Redirect signal of Input channel #4 to Analog Output Channel 0<br>
 if <em>mode</em> == <em>OUTPUTGROUND</em> Ground output signal<br>
</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><em>MPRETURNCODE</em></dd></dl>
<dl compact><dt><b>Warning:</b></dt><dd>For safety, always set analog output channels back to zero volts before the client program exits or physically power cycle the MP device. If you do not set the voltage level back to zero the analog output channels may continue to output a non-zero voltage. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a69" doxytag="mpdev.h::setDigitalAcqChannels" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> MPDLL_EXPORT <a class="el" href="mpdev_8h.html#a5">MPRETURNCODE</a> _stdcall setDigitalAcqChannels           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const BOOL&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>digitalCH</em>[]          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the Digital Channels to Acquire. 
<p>
digitalCH[<em>i</em>] = <em>true</em> implies that the MP device is set to acquire from Digital Channel <em>i</em>. <br>
 digitalCH[<em>i</em>] = <em>false</em> implies that the MP device is set to NOT acquire from Digital Channel <em>i</em>. <br>
 Where 0 &lt;= <em>i</em> &lt; number of digital input channels of the MP device.<p>
<dl compact><dt><b>Note:</b></dt><dd><ul>
<li>The length of <em>digitalCH</em> array must equal to the number of digital input channels of the MP device</li></ul>
</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td></td><td valign=top><em>digitalCH</em>&nbsp;</td><td>an array of booleans, enables/disables acquisition on the corresponding digital input channel</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><em>MPRETURNCODE</em> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a70" doxytag="mpdev.h::setDigitalIO" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> MPDLL_EXPORT <a class="el" href="mpdev_8h.html#a5">MPRETURNCODE</a> _stdcall setDigitalIO           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const DWORD&nbsp;</td>
          <td class="mdname" nowrap> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>const BOOL&nbsp;</td>
          <td class="mdname" nowrap> <em>state</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>const BOOL&nbsp;</td>
          <td class="mdname" nowrap> <em>setnow</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>const <a class="el" href="mpdev_8h.html#a4">DIGITALOPT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>opt</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the State of the Specified Digital I/O Line. 
<p>
<em>true</em> = "high" = 1 = 5.0 volts (TTL high) <br>
 <em>false</em> = "low" = 0 = 0.0 volts (TTL low)<p>
<dl compact><dt><b>Note:</b></dt><dd><ul>
<li>The MP36R/MP36AR has dedicated input and output lines while the MP150/MP160/MP200 has auto-switching digital input and output lines</li><li>For the MP150/MP160/MP200, this function automatically switches the direction of all the Digital I/O lines to output</li><li>The MP36R/MP36AR has 8 digital output lines (digital lines 0 through 7)</li><li>The MP150/MP160/MP200 has 16 digital output lines (digital lines 0 through 15)</li></ul>
</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td></td><td valign=top><em>n</em>&nbsp;</td><td>the Digital I/O line to set where 0 &lt;= <em>n</em> &lt; number of digital I/O channels of the MP device </td></tr>
    <tr><td></td><td valign=top><em>state</em>&nbsp;</td><td>if <em>true</em> the Digital I/O line will be set high, if <em>false</em> it will be set low </td></tr>
    <tr><td></td><td valign=top><em>setnow</em>&nbsp;</td><td>if <em>true</em> the function will send the setting to the MP device, if <em>false</em> it will not send settings until the function is called with <em>setnow</em> set to <em>true</em>. This allows for multiple Digital I/O lines to be configured before they are sent to the MP device. </td></tr>
    <tr><td></td><td valign=top><em>opt</em>&nbsp;</td><td>this parameter is ignored unless <em>setnow</em> = <em>true</em><br>
 if <em>opt</em> == <em>SET_LOW_BITS</em> only digital lines 0-7 are set.<br>
 if <em>opt</em> == <em>SET_HIGH_BITS</em> only digital lines 8-15 are set.<br>
</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><em>MPRETURNCODE</em> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a71" doxytag="mpdev.h::setMPTrigger" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> MPDLL_EXPORT <a class="el" href="mpdev_8h.html#a5">MPRETURNCODE</a> _stdcall setMPTrigger           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const <a class="el" href="mpdev_8h.html#a3">TRIGGEROPT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>option</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>const BOOL&nbsp;</td>
          <td class="mdname" nowrap> <em>posEdge</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>const double&nbsp;</td>
          <td class="mdname" nowrap> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td></td>
          <td class="md" nowrap>const DWORD&nbsp;</td>
          <td class="mdname" nowrap> <em>chNum</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the Triggering Configuration. 
<p>
<dl compact><dt><b>Note:</b></dt><dd><ul>
<li>By default the triggering is set to off</li><li>For the MP36R/MP36AR, the external triggering (<em>MPTRIGEXT</em>) can only be triggered via negative edge (<em>posEdge</em>=<em>false</em>)</li><li>For the MP150/MP160/MP200, digital input channel triggering (<em>MPTRIGDCH</em>) is not possible</li><li>Trigger <em>level</em> is in the scaled units</li><li>If the scaling, gain, or offset of the analog input channel trigger (<em>MPTRIGACH</em>) is modified after configuring the trigger settings, the trigger <em>level</em> is recalculated as follows:<ul>
<li>the previous level is used, regardless of the previous scaling units</li><li>if the previous level is out range of the new Scaled Input Range (see <a class="el" href="mpdev_8h.html#a53">getChScaledInputRange()</a>), the previous level will be clipped to the new range's maximum or minimum value</li></ul>
</li></ul>
</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td></td><td valign=top><em>option</em>&nbsp;</td><td>different ways to set up triggering must use <em>TRIGGEROPT</em> enumerated values.<br>
 if <em>option</em> == <em>MPTRIGOFF</em> the rest of the parameters are ignored by the function. <br>
 if <em>option</em> == <em>MPTRIGEXT</em> the TTL external trigger will be used, parameter <em>posEdge</em> is required and the rest of the parameters are ignored by the function.<br>
 if <em>option</em> == <em>MPTRIGACH</em> one of the analog channel inputs will be used and all the parameters are required by the function.<br>
 if <em>option</em> == <em>MPTRIGDCH</em> one of the digital channel inputs will be used, all the parameters are required by the function except <em>level</em>. The <em>level</em> parameter is ignored. It is automatically set to TTL.<br>
 </td></tr>
    <tr><td></td><td valign=top><em>posEdge</em>&nbsp;</td><td>if <em>true</em> the triggering is set for positive edge trigger, if <em>false</em> it is set for negative edge trigger. This parameter is ignored by the function if <em>option</em> is set to <em>MPTRIGOFF</em>. </td></tr>
    <tr><td></td><td valign=top><em>level</em>&nbsp;</td><td>the scaled units level of the trigger, minRange &lt;= <em>level</em> &lt;= maxRange (see <a class="el" href="mpdev_8h.html#a53">getChScaledInputRange()</a>). This parameter is ignored by the function if <em>option</em> is set to <em>MPTRIGOFF</em>, <em>MPTRIGEXT</em> or <em>MPTRIGDCH</em>. </td></tr>
    <tr><td></td><td valign=top><em>chNum</em>&nbsp;</td><td>the channel where the MP device waits for the trigger. This parameter is ignored by the function if <em>option</em> is set to <em>MPTRIGOFF</em> or <em>MPTRIGEXT</em>.<br>
 if <em>option</em> == <em>MPTRIGACH</em> 0 &lt;= <em>chNum</em> &lt; the number of analog channels of the MP device.<br>
 if <em>option</em> == <em>MPTRIGDCH</em> 0 &lt;= <em>chNum</em> &lt; the number of digital channels of the MP device.<br>
</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><em>MPRETURNCODE</em> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a72" doxytag="mpdev.h::setSampleRate" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> MPDLL_EXPORT <a class="el" href="mpdev_8h.html#a5">MPRETURNCODE</a> _stdcall setSampleRate           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const double&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>rate</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the MP Device Sample Rate. 
<p>
<p>
Listed below are suggested sample rates for a particular MP device.
</p>
<p align="center">
<b>SUPPORTED SAMPLE RATES</b>
</p>
<p align="center">
<b>MP150/MP160</b>
</p>
<table cellspacing="0" cellpadding="0" align="center" border="1" width="40%">
	<tr align="center"><td colspan="2"><b>Sample Rates</b></td><td rowspan="2"><b>Recommended Maximum Number of Active Acquisition Channels</b></td></tr>
	<tr align="center"><td><b>Hertz</b></td><td><b>msec/sample</b></td></tr>
	<tr align="center"><td>200K</td><td>1000/200000.0</td><td>1</td></tr>
	<tr align="center"><td>100K</td><td>1000/100000.0</td><td>2</td></tr>
	<tr align="center"><td>50K</td><td>1000/50000.0</td><td>5</td></tr>
	<tr align="center"><td>40K</td><td>1000/40000.0</td><td>6</td></tr>
	<tr align="center"><td>25K</td><td>1000/25000.0</td><td>10</td></tr>
	<tr align="center"><td>20K</td><td>1000/20000.0</td><td>12</td></tr>
	<tr align="center"><td>12.5K</td><td>1000/12500.0</td><td>16</td></tr>
	<tr align="center"><td>10K</td><td>1000/10000.0</td><td>16</td></tr>
	<tr align="center"><td>6.25K</td><td>1000/6250.0</td><td>16</td></tr>
	<tr align="center"><td>5000.0</td><td>1000/5000.0</td><td>16</td></tr>
	<tr align="center"><td>4000.0</td><td>1000/4000.0</td><td>16</td></tr>
	<tr align="center"><td>2500.0</td><td>1000/2500.0</td><td>16</td></tr>
	<tr align="center"><td>2000.0</td><td>1000/2000.0</td><td>16</td></tr>
	<tr align="center"><td>1250.0</td><td>1000/1250.0</td><td>16</td></tr>
	<tr align="center"><td>1000.0</td><td>1000/1000.0</td><td>16</td></tr>
	<tr align="center"><td>625.0</td><td>1000/625.0</td><td>16</td></tr>
	<tr align="center"><td>500.0</td><td>1000/500.0</td><td>16</td></tr>
	<tr align="center"><td>400.0</td><td>1000/400.0</td><td>16</td></tr>
	<tr align="center"><td>250.0</td><td>1000/250.0</td><td>16</td></tr>
	<tr align="center"><td>200.0</td><td>1000/200.0</td><td>16</td></tr>
	<tr align="center"><td>125.0</td><td>1000/125.0</td><td>16</td></tr>
	<tr align="center"><td>100.0</td><td>1000/100.0</td><td>16</td></tr>
	<tr align="center"><td>62.5</td><td>1000/62.5</td><td>16</td></tr>
	<tr align="center"><td>50.0</td><td>1000/50.0</td><td>16</td></tr>
	<tr align="center"><td>40.0</td><td>1000/40.0</td><td>16</td></tr>
	<tr align="center"><td>25.0</td><td>1000/25.0</td><td>16</td></tr>
	<tr align="center"><td>20.0</td><td>1000/20.0</td><td>16</td></tr>
	<tr align="center"><td>10.0</td><td>1000/10.0</td><td>16</td></tr>
	<tr align="center"><td>6.25</td><td>1000/6.25</td><td>16</td></tr>
	<tr align="center"><td>5.0</td><td>1000/5.0</td><td>16</td></tr>
	<tr align="center"><td>4.0</td><td>1000/4.0</td><td>16</td></tr>
	<tr align="center"><td>2.5</td><td>1000/2.5</td><td>16</td></tr>
	<tr align="center"><td>2.0</td><td>1000/2.0</td><td>16</td></tr>
	<tr align="center"><td>1.25</td><td>1000/1.25</td><td>16</td></tr>
	<tr align="center"><td>1.0</td><td>1000/1.0</td><td>16</td></tr>
	<tr align="center"><td>0.625</td><td>1000/0.625</td><td>16</td></tr>
	<tr align="center"><td>0.5</td><td>1000/0.5</td><td>16</td></tr>
	<tr align="center"><td>0.4</td><td>1000/0.4</td><td>16</td></tr>
	<tr align="center"><td>0.25</td><td>1000/0.25</td><td>16</td></tr>
	<tr align="center"><td>0.2</td><td>1000/0.2</td><td>16</td></tr>
	<tr align="center"><td>0.125</td><td>1000/0.125</td><td>16</td></tr>
	<tr align="center"><td>0.1</td><td>1000/0.1</td><td>16</td></tr>
 </table>

<p align="center">
<b>MP200</b>
</p>
<table cellspacing="0" cellpadding="0" align="center" border="1" width="40%">
	<tr align="center"><td colspan="2"><b>Sample Rates</b></td><td rowspan="2"><b>Recommended Maximum Number of Active Acquisition Channels</b></td></tr>
	<tr align="center"><td><b>Hertz</b></td><td><b>msec/sample</b></td></tr>
	<tr align="center"><td>100K</td><td>1000/100000.0</td><td>16</td></tr>
	<tr align="center"><td>50K</td><td>1000/50000.0</td><td>16</td></tr>
	<tr align="center"><td>20K</td><td>1000/20000.0</td><td>16</td></tr>
	<tr align="center"><td>10K</td><td>1000/10000.0</td><td>16</td></tr>
	<tr align="center"><td>5000.0</td><td>1000/5000.0</td><td>16</td></tr>
	<tr align="center"><td>2000.0</td><td>1000/2000.0</td><td>16</td></tr>
	<tr align="center"><td>1000.0</td><td>1000/1000.0</td><td>16</td></tr>
	<tr align="center"><td>500.0</td><td>1000/500.0</td><td>16</td></tr>
	<tr align="center"><td>200.0</td><td>1000/200.0</td><td>16</td></tr>
	<tr align="center"><td>100.0</td><td>1000/100.0</td><td>16</td></tr>
	<tr align="center"><td>50.0</td><td>1000/50.0</td><td>16</td></tr>
	<tr align="center"><td>20.0</td><td>1000/20.0</td><td>16</td></tr>
	<tr align="center"><td>10.0</td><td>1000/10.0</td><td>16</td></tr>
	<tr align="center"><td>5.0</td><td>1000/5.0</td><td>16</td></tr>
	<tr align="center"><td>2.0</td><td>1000/2.0</td><td>16</td></tr>
	<tr align="center"><td>1.0</td><td>1000/1.0</td><td>16</td></tr>
	<tr align="center"><td>0.5</td><td>1000/0.5</td><td>16</td></tr>
	<tr align="center"><td>0.2</td><td>1000/0.2</td><td>16</td></tr>
	<tr align="center"><td>0.1</td><td>1000/0.1</td><td>16</td></tr>
 </table>
 
 <p align="center">
 <b>MP36R/MP36AR</b>
 </p>
 <table cellspacing="0" cellpadding="0" align="center" border="1" width="40%">
 	<tr align="center"><td colspan="2"><b>Sample Rates</b></td><td rowspan="2"><b>Recommended Maximum Number of Active Acquisition Channels</b></td></tr>
 	<tr align="center"><td><b>Hertz</b></td><td><b>msec/sample</b></td></tr>
 	<tr align="center"><td>100K</td><td>1000/100000.0</td><td>4</td></tr>
 	<tr align="center"><td>50K</td><td>1000/50000.0</td><td>4</td></tr>
 	<tr align="center"><td>25K</td><td>1000/25000.0</td><td>4</td></tr>
 	<tr align="center"><td>20K</td><td>1000/20000.0</td><td>4</td></tr>
 	<tr align="center"><td>10K</td><td>1000/10000.0</td><td>4</td></tr>
 	<tr align="center"><td>5000.0</td><td>1000/5000.0</td><td>4</td></tr>
 	<tr align="center"><td>2000.0</td><td>1000/2000.0</td><td>4</td></tr>
 	<tr align="center"><td>1000.0</td><td>1000/1000.0</td><td>4</td></tr>
 	<tr align="center"><td>500.0</td><td>1000/500.0</td><td>4</td></tr>
 	<tr align="center"><td>200.0</td><td>1000/200.0</td><td>4</td></tr>
 	<tr align="center"><td>100.0</td><td>1000/100.0</td><td>4</td></tr>
 	<tr align="center"><td>50.0</td><td>1000/50.0</td><td>4</td></tr>
 	<tr align="center"><td>20.0</td><td>1000/20.0</td><td>4</td></tr>
 	<tr align="center"><td>10.0</td><td>1000/10.0</td><td>4</td></tr>
 	<tr align="center"><td>5.0</td><td>1000/5.0</td><td>4</td></tr>
 	<tr align="center"><td>2.0</td><td>1000/2.0</td><td>4</td></tr>
  	<tr align="center"><td>1.0</td><td>1000/1.0</td><td>4</td></tr>
  </table>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td></td><td valign=top><em>rate</em>&nbsp;</td><td>MP device sampling rate in msec/sample</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><em>MPRETURNCODE</em></dd></dl>
<dl compact><dt><b>Warning:</b></dt><dd><ul>
<li>Only use the sample rates listed above</li><li>The number of active acquisition channels should not exceed the Maximum Recommended Number of Active Acquisition Channels, the acquisition may fail or not even start otherwise</li><li>Unexpected results may occur if the incoming data are not transferred and processed as quickly and efficiently as possible </li></ul>
</dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a73" doxytag="mpdev.h::startAcquisition" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> MPDLL_EXPORT <a class="el" href="mpdev_8h.html#a5">MPRETURNCODE</a> _stdcall startAcquisition           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Start the Acquisition. 
<p>
<dl compact><dt><b>Note:</b></dt><dd><ul>
<li>At least one analog input channel must be enabled for acquisition</li><li>If a the MP device is configured to trigger, this function will not return until the trigger is received by the MP device</li></ul>
</dd></dl>
<dl compact><dt><b>Returns:</b></dt><dd><em>MPRETURNCODE</em> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a74" doxytag="mpdev.h::startMPAcqDaemon" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> MPDLL_EXPORT <a class="el" href="mpdev_8h.html#a5">MPRETURNCODE</a> _stdcall startMPAcqDaemon           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Start the Acquisition Daemon. 
<p>
Starts a thread (daemon) that downloads the data from the MP device and caches it once acquisition starts. The cache can be retrieved by calling <a class="el" href="mpdev_8h.html#a64">receiveMPData()</a>.<p>
<dl compact><dt><b>Note:</b></dt><dd><ul>
<li>call this function first before calling <a class="el" href="mpdev_8h.html#a73">startAcquisition()</a></li><li>when using this function, you must <b>NOT</b> use any data transfer methods such as, <a class="el" href="mpdev_8h.html#a57">getMPBuffer()</a> and <a class="el" href="mpdev_8h.html#a56">getMostRecentSample()</a> functions, during the same acquisition</li><li>the daemon will not exit until the <a class="el" href="mpdev_8h.html#a75">stopAcquisition()</a> or <a class="el" href="mpdev_8h.html#a49">disconnectMPDev()</a> function is called or an error occurs within the thread</li><li>the thread is spawned from the calling process</li></ul>
</dd></dl>
<dl compact><dt><b>Returns:</b></dt><dd><em>MPRETURNCODE</em> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a75" doxytag="mpdev.h::stopAcquisition" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> MPDLL_EXPORT <a class="el" href="mpdev_8h.html#a5">MPRETURNCODE</a> _stdcall stopAcquisition           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Stop the Acquisition. 
<p>
<dl compact><dt><b>Returns:</b></dt><dd><em>MPRETURNCODE</em> </dd></dl>
    </td>
  </tr>
</table>
<div class="footer">
All trademarks and copyrights used are properties of their respective owners.
<br />
Copyright &copy; 2005-2024 <a href="http://www.biopac.com/" onclick="bwin = window.open('http://www.biopac.com/','bwin'); bwin.focus(); return false;">BIOPAC Systems, Inc.</a> All Rights Reserved.
</div>
</body>
</html>
